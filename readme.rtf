Hello! Here are the patterns I used and where I used them:

Singleton:
	Class Admin (handles admin UI)

Singleton:
	Class Database (allows easy access to all users and groups)

Observer Pattern:
	Abstract Class Subject
		I made this a class as opposed to an interface so I could write a ’post’ method that notified all observers. The User class inherited 
		this. I thought it was a clean way to do it.
	Interface Observer
	Class User (child of Subject and implements Observer)

Composite Pattern:
	Interface Entry
	Class User (implements Entry)
	Class Group (implements Entry; has Entry list)

Visitor Pattern:
	Visitees (those being visited):
		Interface Vistee (has accept method signature)
		Interface Entry (extends Visitee)
		Class User (implements Entry and thus Visitee)
		Class Group (implements Entry and thus Visitee)
	Vistor:
		Interface EntryVistory (has visit method signature)
		Class CountTweetVisitor (implements EntryVisitor)
		Class CountPositiveTweetVisitor (implements EntryVisitor)
		Class CountUser (implements EntryVisitor)
		Class CountGroup (implements EntryVisitor)
	
Model View Controller Pattern:
	This was a pattern mentioned in the QA session, and I tried my best to implement it in my program. I believe I relatively successful, although I’m sure I can further 	optimize it. I have a recursive method in adminPanel ‘addNodes(UserGroup root)’ 	that when 	given the Root (a UserGroup class) returns a properly structured JTree.
	As mentioned, I’m sure this can be optimized further, but what I have so far was really quick and easy to implement and did not add much code.
	








